#! /usr/bin/env python
# coding=utf-8

"""
Utilities for fetching and unpacking packages from pypi
"""
from collections import Counter
import fnmatch
import os

from pylint.lint import Run
from pylint.reporters.text import TextReporter

SCORING_VALUES = {
    'F': 5,
    'E': 4,
    'W': 3,
    'R': 2,
    'C': 1
}

def score(package_path):
    """
    Runs pylint on a package and returns a score
    Lower score is better

    :param package_path: path of the package to score
    :return: number of score
    """
    python_files = find_files(package_path, '*.py')

    total_counter = Counter()

    for python_file in python_files:
        output = run_pylint(python_file)
        counter = parse_pylint_output(output)
        total_counter += counter

    score_value = 0

    for count, stat in enumerate(total_counter):
        score_value += SCORING_VALUES[stat] * count

    return score_value / 5

def parse_pylint_output(output):
    """
    Parses pylint output, counting number of errors, conventions, etc
    :param output: output list generated by run_pylint()
    :return:
    """

    stripped_output = [x[0] for x in output]

    counter = Counter(stripped_output)

    return counter

class WritableObject(object):
    """
    Dummy output stream for pylint"
    """
    def __init__(self):
        self.content = []
    def write(self, st):
        "dummy write"
        self.content.append(st)
    def read(self):
        "dummy read"
        return self.content

def run_pylint(filename):
    """
    Runs pylint on a given file
    :param filename:
    :return: list of pylint errors
    """
    ARGS = [
        '-r',
        'n'
    ]
    pylint_output = WritableObject()
    Run([filename]+ARGS, reporter=TextReporter(pylint_output), exit=False)

    lines = []
    for line in pylint_output.read():
        if not line.startswith('*') and line != '\n':
            lines.append(line)

    return lines

def find_files(directory, pattern):
    """
    Recusively finds files in a directory re
    :param directory: base directory
    :param pattern: wildcard pattern
    :return: generator with filenames matching pattern
    """
    for root, __, files in os.walk(directory):
        for basename in files:
            if fnmatch.fnmatch(basename, pattern):
                filename = os.path.join(root, basename)
                yield filename
